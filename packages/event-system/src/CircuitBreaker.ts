// Circuit Breaker Implementation for Self-Healing System\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;\n  recoveryTimeout: number;\n  monitoringPeriod: number;\n  halfOpenMaxCalls?: number;\n}\n\nexport enum CircuitBreakerState {\n  CLOSED = 'CLOSED',\n  OPEN = 'OPEN',\n  HALF_OPEN = 'HALF_OPEN'\n}\n\nexport interface CircuitBreakerMetrics {\n  totalCalls: number;\n  successfulCalls: number;\n  failedCalls: number;\n  consecutiveFailures: number;\n  lastFailureTime?: Date;\n  lastSuccessTime?: Date;\n  stateChanges: Array<{\n    from: CircuitBreakerState;\n    to: CircuitBreakerState;\n    timestamp: Date;\n    reason: string;\n  }>;\n}\n\nexport class CircuitBreaker {\n  private state: CircuitBreakerState = CircuitBreakerState.CLOSED;\n  private config: Required<CircuitBreakerConfig>;\n  private metrics: CircuitBreakerMetrics;\n  private nextAttempt: number = 0;\n  private halfOpenCalls: number = 0;\n  private monitoringTimer?: NodeJS.Timeout;\n\n  constructor(config: CircuitBreakerConfig) {\n    this.config = {\n      halfOpenMaxCalls: 3,\n      ...config\n    };\n    \n    this.metrics = {\n      totalCalls: 0,\n      successfulCalls: 0,\n      failedCalls: 0,\n      consecutiveFailures: 0,\n      stateChanges: []\n    };\n    \n    this.startMonitoring();\n  }\n\n  public async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.state === CircuitBreakerState.OPEN) {\n      if (Date.now() < this.nextAttempt) {\n        throw new Error('Circuit breaker is OPEN');\n      } else {\n        this.changeState(CircuitBreakerState.HALF_OPEN, 'Recovery timeout elapsed');\n      }\n    }\n\n    if (this.state === CircuitBreakerState.HALF_OPEN) {\n      if (this.halfOpenCalls >= this.config.halfOpenMaxCalls) {\n        throw new Error('Circuit breaker HALF_OPEN call limit exceeded');\n      }\n      this.halfOpenCalls++;\n    }\n\n    this.metrics.totalCalls++;\n\n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.metrics.successfulCalls++;\n    this.metrics.consecutiveFailures = 0;\n    this.metrics.lastSuccessTime = new Date();\n\n    if (this.state === CircuitBreakerState.HALF_OPEN) {\n      this.changeState(CircuitBreakerState.CLOSED, 'Successful call in HALF_OPEN state');\n      this.halfOpenCalls = 0;\n    }\n  }\n\n  private onFailure(): void {\n    this.metrics.failedCalls++;\n    this.metrics.consecutiveFailures++;\n    this.metrics.lastFailureTime = new Date();\n\n    if (this.state === CircuitBreakerState.HALF_OPEN) {\n      this.changeState(CircuitBreakerState.OPEN, 'Failure in HALF_OPEN state');\n      this.halfOpenCalls = 0;\n      this.nextAttempt = Date.now() + this.config.recoveryTimeout;\n    } else if (this.state === CircuitBreakerState.CLOSED) {\n      if (this.metrics.consecutiveFailures >= this.config.failureThreshold) {\n        this.changeState(CircuitBreakerState.OPEN, 'Failure threshold exceeded');\n        this.nextAttempt = Date.now() + this.config.recoveryTimeout;\n      }\n    }\n  }\n\n  private changeState(newState: CircuitBreakerState, reason: string): void {\n    const oldState = this.state;\n    this.state = newState;\n    \n    this.metrics.stateChanges.push({\n      from: oldState,\n      to: newState,\n      timestamp: new Date(),\n      reason\n    });\n\n    // Keep only recent state changes (last 100)\n    if (this.metrics.stateChanges.length > 100) {\n      this.metrics.stateChanges = this.metrics.stateChanges.slice(-100);\n    }\n  }\n\n  private startMonitoring(): void {\n    this.monitoringTimer = setInterval(() => {\n      this.resetMetricsIfNeeded();\n    }, this.config.monitoringPeriod);\n  }\n\n  private resetMetricsIfNeeded(): void {\n    // Reset metrics periodically to prevent stale data from affecting decisions\n    const now = Date.now();\n    const resetThreshold = this.config.monitoringPeriod * 10; // Reset after 10 monitoring periods\n    \n    if (this.metrics.lastFailureTime && \n        (now - this.metrics.lastFailureTime.getTime()) > resetThreshold) {\n      this.metrics.consecutiveFailures = 0;\n    }\n  }\n\n  public forceOpen(): void {\n    this.changeState(CircuitBreakerState.OPEN, 'Manually forced open');\n    this.nextAttempt = Date.now() + this.config.recoveryTimeout;\n  }\n\n  public forceClose(): void {\n    this.changeState(CircuitBreakerState.CLOSED, 'Manually forced closed');\n    this.metrics.consecutiveFailures = 0;\n    this.halfOpenCalls = 0;\n  }\n\n  public forceHalfOpen(): void {\n    this.changeState(CircuitBreakerState.HALF_OPEN, 'Manually forced half-open');\n    this.halfOpenCalls = 0;\n  }\n\n  public getState(): CircuitBreakerState {\n    return this.state;\n  }\n\n  public getMetrics(): CircuitBreakerMetrics {\n    return { ...this.metrics };\n  }\n\n  public isCallAllowed(): boolean {\n    if (this.state === CircuitBreakerState.CLOSED) {\n      return true;\n    }\n    \n    if (this.state === CircuitBreakerState.OPEN) {\n      return Date.now() >= this.nextAttempt;\n    }\n    \n    if (this.state === CircuitBreakerState.HALF_OPEN) {\n      return this.halfOpenCalls < this.config.halfOpenMaxCalls;\n    }\n    \n    return false;\n  }\n\n  public getFailureRate(): number {\n    if (this.metrics.totalCalls === 0) {\n      return 0;\n    }\n    return this.metrics.failedCalls / this.metrics.totalCalls;\n  }\n\n  public getSuccessRate(): number {\n    if (this.metrics.totalCalls === 0) {\n      return 0;\n    }\n    return this.metrics.successfulCalls / this.metrics.totalCalls;\n  }\n\n  public destroy(): void {\n    if (this.monitoringTimer) {\n      clearInterval(this.monitoringTimer);\n      this.monitoringTimer = undefined;\n    }\n  }\n}"
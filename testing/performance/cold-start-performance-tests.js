// Cold Start Performance Tests for Storytailor Lambda Functions\n// Tests the <150ms cold start requirement\n\nconst AWS = require('aws-sdk');\nconst https = require('https');\nconst { performance } = require('perf_hooks');\n\n// Configure AWS SDK\nAWS.config.update({\n  region: process.env.AWS_REGION || 'us-east-1'\n});\n\nconst lambda = new AWS.Lambda();\nconst cloudwatch = new AWS.CloudWatch();\n\nclass ColdStartTester {\n  constructor(config) {\n    this.config = {\n      functionNames: [],\n      apiEndpoints: [],\n      testIterations: 100,\n      coldStartThreshold: 150, // milliseconds\n      warmupDelay: 30000, // 30 seconds between cold starts\n      ...config\n    };\n    this.results = [];\n  }\n\n  async sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async invokeLambdaFunction(functionName) {\n    const startTime = performance.now();\n    \n    try {\n      const params = {\n        FunctionName: functionName,\n        InvocationType: 'RequestResponse',\n        Payload: JSON.stringify({\n          httpMethod: 'GET',\n          path: '/health',\n          headers: {},\n          body: null\n        })\n      };\n      \n      const result = await lambda.invoke(params).promise();\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      // Parse response to check if it was a cold start\n      let responsePayload = {};\n      try {\n        responsePayload = JSON.parse(result.Payload);\n      } catch (e) {\n        console.warn(`Failed to parse response payload for ${functionName}`);\n      }\n      \n      return {\n        functionName,\n        duration,\n        statusCode: responsePayload.statusCode || 200,\n        isColdStart: this.detectColdStart(result, responsePayload),\n        timestamp: new Date().toISOString(),\n        success: result.StatusCode === 200\n      };\n    } catch (error) {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      return {\n        functionName,\n        duration,\n        statusCode: 500,\n        isColdStart: true, // Assume cold start on error\n        timestamp: new Date().toISOString(),\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  detectColdStart(lambdaResult, responsePayload) {\n    // Check various indicators of cold start\n    \n    // 1. Check X-Ray trace for INIT duration\n    if (lambdaResult.LogResult) {\n      const logData = Buffer.from(lambdaResult.LogResult, 'base64').toString();\n      if (logData.includes('INIT_START') || logData.includes('INIT_REPORT')) {\n        return true;\n      }\n    }\n    \n    // 2. Check response headers for cold start indicators\n    if (responsePayload.headers && responsePayload.headers['x-cold-start']) {\n      return responsePayload.headers['x-cold-start'] === 'true';\n    }\n    \n    // 3. Duration-based heuristic (>100ms likely cold start)\n    // This is less reliable but can be used as fallback\n    return false; // We'll rely on forced cold starts\n  }\n\n  async forceColdStart(functionName) {\n    try {\n      // Update function configuration to force cold start\n      // This is a common technique to ensure we're testing cold starts\n      const currentConfig = await lambda.getFunctionConfiguration({\n        FunctionName: functionName\n      }).promise();\n      \n      // Update environment variable to force new container\n      const newEnvVars = {\n        ...currentConfig.Environment?.Variables,\n        COLD_START_TEST_TIMESTAMP: Date.now().toString()\n      };\n      \n      await lambda.updateFunctionConfiguration({\n        FunctionName: functionName,\n        Environment: {\n          Variables: newEnvVars\n        }\n      }).promise();\n      \n      // Wait for update to complete\n      await this.waitForFunctionUpdate(functionName);\n      \n      console.log(`Forced cold start for ${functionName}`);\n    } catch (error) {\n      console.warn(`Failed to force cold start for ${functionName}: ${error.message}`);\n    }\n  }\n\n  async waitForFunctionUpdate(functionName) {\n    let attempts = 0;\n    const maxAttempts = 30;\n    \n    while (attempts < maxAttempts) {\n      try {\n        const config = await lambda.getFunctionConfiguration({\n          FunctionName: functionName\n        }).promise();\n        \n        if (config.State === 'Active' && config.LastUpdateStatus === 'Successful') {\n          return;\n        }\n        \n        await this.sleep(1000);\n        attempts++;\n      } catch (error) {\n        console.warn(`Error checking function update status: ${error.message}`);\n        await this.sleep(1000);\n        attempts++;\n      }\n    }\n    \n    throw new Error(`Function ${functionName} update did not complete within timeout`);\n  }\n\n  async testApiEndpointColdStart(endpoint) {\n    const startTime = performance.now();\n    \n    return new Promise((resolve) => {\n      const url = new URL(endpoint);\n      const options = {\n        hostname: url.hostname,\n        port: url.port || (url.protocol === 'https:' ? 443 : 80),\n        path: url.pathname + url.search,\n        method: 'GET',\n        headers: {\n          'User-Agent': 'ColdStartTester/1.0',\n          'Accept': 'application/json'\n        },\n        timeout: 10000\n      };\n      \n      const req = https.request(options, (res) => {\n        const endTime = performance.now();\n        const duration = endTime - startTime;\n        \n        let body = '';\n        res.on('data', (chunk) => {\n          body += chunk;\n        });\n        \n        res.on('end', () => {\n          resolve({\n            endpoint,\n            duration,\n            statusCode: res.statusCode,\n            isColdStart: res.headers['x-cold-start'] === 'true' || duration > 100,\n            timestamp: new Date().toISOString(),\n            success: res.statusCode >= 200 && res.statusCode < 300,\n            headers: res.headers\n          });\n        });\n      });\n      \n      req.on('error', (error) => {\n        const endTime = performance.now();\n        const duration = endTime - startTime;\n        \n        resolve({\n          endpoint,\n          duration,\n          statusCode: 500,\n          isColdStart: true,\n          timestamp: new Date().toISOString(),\n          success: false,\n          error: error.message\n        });\n      });\n      \n      req.on('timeout', () => {\n        req.destroy();\n        const endTime = performance.now();\n        const duration = endTime - startTime;\n        \n        resolve({\n          endpoint,\n          duration,\n          statusCode: 408,\n          isColdStart: true,\n          timestamp: new Date().toISOString(),\n          success: false,\n          error: 'Request timeout'\n        });\n      });\n      \n      req.end();\n    });\n  }\n\n  async testLambdaColdStarts() {\n    console.log('Testing Lambda function cold starts...');\n    \n    for (const functionName of this.config.functionNames) {\n      console.log(`\\nTesting ${functionName}...`);\n      \n      const functionResults = [];\n      \n      for (let i = 0; i < this.config.testIterations; i++) {\n        console.log(`  Iteration ${i + 1}/${this.config.testIterations}`);\n        \n        // Force cold start\n        await this.forceColdStart(functionName);\n        \n        // Wait a bit to ensure cold start\n        await this.sleep(2000);\n        \n        // Test the function\n        const result = await this.invokeLambdaFunction(functionName);\n        functionResults.push(result);\n        \n        console.log(`    Duration: ${result.duration.toFixed(2)}ms, Success: ${result.success}`);\n        \n        // Wait before next iteration to allow cleanup\n        if (i < this.config.testIterations - 1) {\n          await this.sleep(this.config.warmupDelay);\n        }\n      }\n      \n      this.results.push(...functionResults);\n    }\n  }\n\n  async testApiColdStarts() {\n    console.log('Testing API endpoint cold starts...');\n    \n    for (const endpoint of this.config.apiEndpoints) {\n      console.log(`\\nTesting ${endpoint}...`);\n      \n      const endpointResults = [];\n      \n      for (let i = 0; i < this.config.testIterations; i++) {\n        console.log(`  Iteration ${i + 1}/${this.config.testIterations}`);\n        \n        // Test the endpoint\n        const result = await this.testApiEndpointColdStart(endpoint);\n        endpointResults.push(result);\n        \n        console.log(`    Duration: ${result.duration.toFixed(2)}ms, Success: ${result.success}`);\n        \n        // Wait before next iteration\n        if (i < this.config.testIterations - 1) {\n          await this.sleep(this.config.warmupDelay);\n        }\n      }\n      \n      this.results.push(...endpointResults);\n    }\n  }\n\n  analyzeResults() {\n    console.log('\\n=== Cold Start Performance Analysis ===');\n    \n    // Group results by function/endpoint\n    const groupedResults = {};\n    \n    this.results.forEach(result => {\n      const key = result.functionName || result.endpoint;\n      if (!groupedResults[key]) {\n        groupedResults[key] = [];\n      }\n      groupedResults[key].push(result);\n    });\n    \n    const analysis = {\n      timestamp: new Date().toISOString(),\n      summary: {\n        totalTests: this.results.length,\n        successfulTests: this.results.filter(r => r.success).length,\n        coldStartThreshold: this.config.coldStartThreshold,\n        overallPassRate: 0\n      },\n      detailedResults: {}\n    };\n    \n    let totalPassed = 0;\n    let totalTests = 0;\n    \n    Object.entries(groupedResults).forEach(([name, results]) => {\n      const durations = results.filter(r => r.success).map(r => r.duration);\n      const coldStartDurations = results.filter(r => r.success && r.isColdStart).map(r => r.duration);\n      \n      if (durations.length === 0) {\n        console.log(`\\n${name}: No successful tests`);\n        return;\n      }\n      \n      const stats = {\n        totalTests: results.length,\n        successfulTests: durations.length,\n        coldStartTests: coldStartDurations.length,\n        averageDuration: durations.reduce((a, b) => a + b, 0) / durations.length,\n        medianDuration: this.calculateMedian(durations),\n        p95Duration: this.calculatePercentile(durations, 95),\n        p99Duration: this.calculatePercentile(durations, 99),\n        minDuration: Math.min(...durations),\n        maxDuration: Math.max(...durations),\n        underThreshold: durations.filter(d => d <= this.config.coldStartThreshold).length,\n        overThreshold: durations.filter(d => d > this.config.coldStartThreshold).length,\n        passRate: (durations.filter(d => d <= this.config.coldStartThreshold).length / durations.length) * 100\n      };\n      \n      // Cold start specific stats\n      if (coldStartDurations.length > 0) {\n        stats.coldStartStats = {\n          averageColdStart: coldStartDurations.reduce((a, b) => a + b, 0) / coldStartDurations.length,\n          medianColdStart: this.calculateMedian(coldStartDurations),\n          p95ColdStart: this.calculatePercentile(coldStartDurations, 95),\n          maxColdStart: Math.max(...coldStartDurations),\n          coldStartPassRate: (coldStartDurations.filter(d => d <= this.config.coldStartThreshold).length / coldStartDurations.length) * 100\n        };\n      }\n      \n      analysis.detailedResults[name] = stats;\n      totalPassed += stats.underThreshold;\n      totalTests += stats.successfulTests;\n      \n      // Console output\n      console.log(`\\n${name}:`);\n      console.log(`  Total Tests: ${stats.totalTests}`);\n      console.log(`  Successful: ${stats.successfulTests}`);\n      console.log(`  Cold Starts: ${stats.coldStartTests}`);\n      console.log(`  Average Duration: ${stats.averageDuration.toFixed(2)}ms`);\n      console.log(`  Median Duration: ${stats.medianDuration.toFixed(2)}ms`);\n      console.log(`  P95 Duration: ${stats.p95Duration.toFixed(2)}ms`);\n      console.log(`  P99 Duration: ${stats.p99Duration.toFixed(2)}ms`);\n      console.log(`  Min Duration: ${stats.minDuration.toFixed(2)}ms`);\n      console.log(`  Max Duration: ${stats.maxDuration.toFixed(2)}ms`);\n      console.log(`  Under ${this.config.coldStartThreshold}ms: ${stats.underThreshold}/${stats.successfulTests} (${stats.passRate.toFixed(1)}%)`);\n      \n      if (stats.coldStartStats) {\n        console.log(`  Cold Start Average: ${stats.coldStartStats.averageColdStart.toFixed(2)}ms`);\n        console.log(`  Cold Start P95: ${stats.coldStartStats.p95ColdStart.toFixed(2)}ms`);\n        console.log(`  Cold Start Pass Rate: ${stats.coldStartStats.coldStartPassRate.toFixed(1)}%`);\n      }\n      \n      // Performance assessment\n      if (stats.passRate >= 95) {\n        console.log(`  ✅ EXCELLENT: ${stats.passRate.toFixed(1)}% under threshold`);\n      } else if (stats.passRate >= 90) {\n        console.log(`  ✅ GOOD: ${stats.passRate.toFixed(1)}% under threshold`);\n      } else if (stats.passRate >= 80) {\n        console.log(`  ⚠️  WARNING: ${stats.passRate.toFixed(1)}% under threshold`);\n      } else {\n        console.log(`  ❌ CRITICAL: ${stats.passRate.toFixed(1)}% under threshold`);\n      }\n    });\n    \n    analysis.summary.overallPassRate = totalTests > 0 ? (totalPassed / totalTests) * 100 : 0;\n    \n    console.log(`\\n=== Overall Summary ===`);\n    console.log(`Total Tests: ${analysis.summary.totalTests}`);\n    console.log(`Successful Tests: ${analysis.summary.successfulTests}`);\n    console.log(`Overall Pass Rate: ${analysis.summary.overallPassRate.toFixed(1)}%`);\n    console.log(`Cold Start Threshold: ${this.config.coldStartThreshold}ms`);\n    \n    if (analysis.summary.overallPassRate >= 95) {\n      console.log(`✅ SYSTEM PERFORMANCE: EXCELLENT`);\n    } else if (analysis.summary.overallPassRate >= 90) {\n      console.log(`✅ SYSTEM PERFORMANCE: GOOD`);\n    } else if (analysis.summary.overallPassRate >= 80) {\n      console.log(`⚠️  SYSTEM PERFORMANCE: NEEDS IMPROVEMENT`);\n    } else {\n      console.log(`❌ SYSTEM PERFORMANCE: CRITICAL ISSUES`);\n    }\n    \n    return analysis;\n  }\n\n  calculateMedian(values) {\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;\n  }\n\n  calculatePercentile(values, percentile) {\n    const sorted = [...values].sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n    return sorted[Math.max(0, Math.min(index, sorted.length - 1))];\n  }\n\n  async publishMetricsToCloudWatch(analysis) {\n    console.log('\\nPublishing metrics to CloudWatch...');\n    \n    const namespace = 'Storytailor/ColdStart';\n    const timestamp = new Date();\n    \n    const metricData = [];\n    \n    // Overall metrics\n    metricData.push({\n      MetricName: 'OverallPassRate',\n      Value: analysis.summary.overallPassRate,\n      Unit: 'Percent',\n      Timestamp: timestamp\n    });\n    \n    metricData.push({\n      MetricName: 'TotalTests',\n      Value: analysis.summary.totalTests,\n      Unit: 'Count',\n      Timestamp: timestamp\n    });\n    \n    // Per-function/endpoint metrics\n    Object.entries(analysis.detailedResults).forEach(([name, stats]) => {\n      const dimensions = [{\n        Name: 'FunctionOrEndpoint',\n        Value: name\n      }];\n      \n      metricData.push(\n        {\n          MetricName: 'AverageDuration',\n          Value: stats.averageDuration,\n          Unit: 'Milliseconds',\n          Dimensions: dimensions,\n          Timestamp: timestamp\n        },\n        {\n          MetricName: 'P95Duration',\n          Value: stats.p95Duration,\n          Unit: 'Milliseconds',\n          Dimensions: dimensions,\n          Timestamp: timestamp\n        },\n        {\n          MetricName: 'PassRate',\n          Value: stats.passRate,\n          Unit: 'Percent',\n          Dimensions: dimensions,\n          Timestamp: timestamp\n        }\n      );\n      \n      if (stats.coldStartStats) {\n        metricData.push(\n          {\n            MetricName: 'ColdStartAverageDuration',\n            Value: stats.coldStartStats.averageColdStart,\n            Unit: 'Milliseconds',\n            Dimensions: dimensions,\n            Timestamp: timestamp\n          },\n          {\n            MetricName: 'ColdStartPassRate',\n            Value: stats.coldStartStats.coldStartPassRate,\n            Unit: 'Percent',\n            Dimensions: dimensions,\n            Timestamp: timestamp\n          }\n        );\n      }\n    });\n    \n    // Send metrics in batches (CloudWatch limit is 20 per request)\n    const batchSize = 20;\n    for (let i = 0; i < metricData.length; i += batchSize) {\n      const batch = metricData.slice(i, i + batchSize);\n      \n      try {\n        await cloudwatch.putMetricData({\n          Namespace: namespace,\n          MetricData: batch\n        }).promise();\n        \n        console.log(`Published ${batch.length} metrics to CloudWatch`);\n      } catch (error) {\n        console.error(`Failed to publish metrics batch: ${error.message}`);\n      }\n    }\n  }\n\n  async runAllTests() {\n    console.log('Starting cold start performance tests...');\n    console.log(`Cold start threshold: ${this.config.coldStartThreshold}ms`);\n    console.log(`Test iterations per function/endpoint: ${this.config.testIterations}`);\n    \n    // Test Lambda functions\n    if (this.config.functionNames.length > 0) {\n      await this.testLambdaColdStarts();\n    }\n    \n    // Test API endpoints\n    if (this.config.apiEndpoints.length > 0) {\n      await this.testApiColdStarts();\n    }\n    \n    // Analyze results\n    const analysis = this.analyzeResults();\n    \n    // Publish metrics to CloudWatch\n    try {\n      await this.publishMetricsToCloudWatch(analysis);\n    } catch (error) {\n      console.warn(`Failed to publish CloudWatch metrics: ${error.message}`);\n    }\n    \n    return analysis;\n  }\n}\n\n// CLI interface\nif (require.main === module) {\n  const config = {\n    functionNames: process.env.LAMBDA_FUNCTIONS ? process.env.LAMBDA_FUNCTIONS.split(',') : [\n      'storytailor-router',\n      'storytailor-auth-agent',\n      'storytailor-content-agent',\n      'storytailor-library-agent',\n      'storytailor-emotion-agent',\n      'storytailor-commerce-agent',\n      'storytailor-insights-agent',\n      'storytailor-smart-home-agent'\n    ],\n    apiEndpoints: process.env.API_ENDPOINTS ? process.env.API_ENDPOINTS.split(',') : [\n      'https://orchestrator.storytailor.com/health',\n      'https://orchestrator.storytailor.com/v1/conversation/start',\n      'https://orchestrator.storytailor.com/v1/stories',\n      'https://orchestrator.storytailor.com/v1/characters'\n    ],\n    testIterations: parseInt(process.env.TEST_ITERATIONS) || 50,\n    coldStartThreshold: parseInt(process.env.COLD_START_THRESHOLD) || 150,\n    warmupDelay: parseInt(process.env.WARMUP_DELAY) || 30000\n  };\n  \n  const tester = new ColdStartTester(config);\n  \n  tester.runAllTests()\n    .then(analysis => {\n      // Save results to file\n      const fs = require('fs');\n      fs.writeFileSync('cold-start-test-results.json', JSON.stringify(analysis, null, 2));\n      console.log('\\nResults saved to cold-start-test-results.json');\n      \n      // Exit with appropriate code\n      if (analysis.summary.overallPassRate >= 95) {\n        process.exit(0); // Success\n      } else if (analysis.summary.overallPassRate >= 80) {\n        process.exit(1); // Warning\n      } else {\n        process.exit(2); // Critical\n      }\n    })\n    .catch(error => {\n      console.error('Cold start testing failed:', error);\n      process.exit(3);\n    });\n}\n\nmodule.exports = ColdStartTester;"
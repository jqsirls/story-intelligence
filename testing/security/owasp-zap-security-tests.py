#!/usr/bin/env python3
"""
OWASP ZAP Security Testing Suite for Storytailor Multi-Agent System
Tests for COPPA/GDPR compliance, authentication, and general security vulnerabilities
"""

import os
import sys
import time
import json
import requests
from zapv2 import ZAPv2
import logging
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('security_test_results.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class SecurityTestResult:
    test_name: str
    status: str  # PASS, FAIL, WARNING
    details: str
    risk_level: str  # HIGH, MEDIUM, LOW, INFO
    compliance_impact: Optional[str] = None

class StorytellerSecurityTester:
    def __init__(self, target_url: str, api_key: str, zap_proxy_port: int = 8080):
        self.target_url = target_url.rstrip('/')\n        self.api_key = api_key\n        self.zap_proxy_port = zap_proxy_port\n        self.zap = ZAPv2(proxies={'http': f'http://127.0.0.1:{zap_proxy_port}', \n                                  'https': f'http://127.0.0.1:{zap_proxy_port}'})\n        self.results: List[SecurityTestResult] = []\n        self.session = requests.Session()\n        \n        # Configure session for ZAP proxy\n        self.session.proxies = {\n            'http': f'http://127.0.0.1:{zap_proxy_port}',\n            'https': f'http://127.0.0.1:{zap_proxy_port}'\n        }\n        self.session.verify = False  # Disable SSL verification for proxy\n        \n    def add_result(self, test_name: str, status: str, details: str, \n                   risk_level: str, compliance_impact: Optional[str] = None):\n        \"\"\"Add a test result to the results list\"\"\"\n        result = SecurityTestResult(\n            test_name=test_name,\n            status=status,\n            details=details,\n            risk_level=risk_level,\n            compliance_impact=compliance_impact\n        )\n        self.results.append(result)\n        logger.info(f\"{test_name}: {status} - {details}\")\n        \n    def setup_zap(self):\n        \"\"\"Initialize ZAP and configure for testing\"\"\"\n        logger.info(\"Setting up OWASP ZAP...\")\n        \n        try:\n            # Check if ZAP is running\n            zap_version = self.zap.core.version\n            logger.info(f\"ZAP version: {zap_version}\")\n            \n            # Create new session\n            self.zap.core.new_session()\n            \n            # Configure ZAP for API testing\n            self.zap.core.set_option_use_proxy_chain(False)\n            \n            # Add target to scope\n            self.zap.core.include_in_context('Default Context', f'{self.target_url}.*')\n            \n            logger.info(\"ZAP setup completed\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to setup ZAP: {e}\")\n            return False\n    \n    def test_authentication_security(self):\n        \"\"\"Test authentication and authorization security\"\"\"\n        logger.info(\"Testing authentication security...\")\n        \n        # Test 1: Unauthenticated access\n        try:\n            response = requests.get(f\"{self.target_url}/v1/conversation/start\")\n            if response.status_code == 200:\n                self.add_result(\n                    \"Unauthenticated Access\",\n                    \"FAIL\",\n                    \"API allows unauthenticated access to protected endpoints\",\n                    \"HIGH\",\n                    \"COPPA/GDPR: Unauthorized access to child data\"\n                )\n            else:\n                self.add_result(\n                    \"Unauthenticated Access\",\n                    \"PASS\",\n                    \"API properly rejects unauthenticated requests\",\n                    \"INFO\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"Unauthenticated Access\",\n                \"WARNING\",\n                f\"Test failed with error: {e}\",\n                \"MEDIUM\"\n            )\n        \n        # Test 2: Invalid API key\n        try:\n            headers = {'Authorization': 'Bearer invalid-key'}\n            response = requests.get(f\"{self.target_url}/v1/conversation/start\", headers=headers)\n            if response.status_code == 200:\n                self.add_result(\n                    \"Invalid API Key\",\n                    \"FAIL\",\n                    \"API accepts invalid API keys\",\n                    \"HIGH\",\n                    \"Authentication bypass vulnerability\"\n                )\n            else:\n                self.add_result(\n                    \"Invalid API Key\",\n                    \"PASS\",\n                    \"API properly rejects invalid API keys\",\n                    \"INFO\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"Invalid API Key\",\n                \"WARNING\",\n                f\"Test failed with error: {e}\",\n                \"MEDIUM\"\n            )\n        \n        # Test 3: JWT token validation\n        try:\n            # Test with malformed JWT\n            headers = {'Authorization': 'Bearer [REDACTED_JWT]'}\n            response = requests.get(f\"{self.target_url}/v1/conversation/start\", headers=headers)\n            if response.status_code == 200:\n                self.add_result(\n                    \"JWT Validation\",\n                    \"FAIL\",\n                    \"API accepts malformed JWT tokens\",\n                    \"HIGH\",\n                    \"Token validation bypass\"\n                )\n            else:\n                self.add_result(\n                    \"JWT Validation\",\n                    \"PASS\",\n                    \"API properly validates JWT tokens\",\n                    \"INFO\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"JWT Validation\",\n                \"WARNING\",\n                f\"Test failed with error: {e}\",\n                \"MEDIUM\"\n            )\n    \n    def test_coppa_compliance(self):\n        \"\"\"Test COPPA compliance requirements\"\"\"\n        logger.info(\"Testing COPPA compliance...\")\n        \n        # Test 1: Age verification for under-13 users\n        try:\n            headers = {'Authorization': f'Bearer {self.api_key}'}\n            payload = {\n                'platform': 'api',\n                'user': {\n                    'email': 'child@example.com',\n                    'age': 10,  # Under 13\n                    'parentalConsent': False\n                }\n            }\n            response = self.session.post(\n                f\"{self.target_url}/v1/conversation/start\", \n                json=payload, \n                headers=headers\n            )\n            \n            if response.status_code == 200:\n                self.add_result(\n                    \"COPPA Age Verification\",\n                    \"FAIL\",\n                    \"System allows under-13 users without parental consent\",\n                    \"HIGH\",\n                    \"COPPA violation: Missing parental consent for under-13 users\"\n                )\n            else:\n                self.add_result(\n                    \"COPPA Age Verification\",\n                    \"PASS\",\n                    \"System properly requires parental consent for under-13 users\",\n                    \"INFO\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"COPPA Age Verification\",\n                \"WARNING\",\n                f\"Test failed with error: {e}\",\n                \"MEDIUM\"\n            )\n        \n        # Test 2: Data collection minimization\n        try:\n            headers = {'Authorization': f'Bearer {self.api_key}'}\n            payload = {\n                'platform': 'api',\n                'user': {\n                    'email': 'child@example.com',\n                    'age': 10,\n                    'fullName': 'Child Name',\n                    'address': '123 Main St',\n                    'phoneNumber': '555-1234',\n                    'parentalConsent': True\n                }\n            }\n            response = self.session.post(\n                f\"{self.target_url}/v1/conversation/start\", \n                json=payload, \n                headers=headers\n            )\n            \n            # Check if excessive data is being collected\n            if 'address' in str(response.content) or 'phoneNumber' in str(response.content):\n                self.add_result(\n                    \"COPPA Data Minimization\",\n                    \"FAIL\",\n                    \"System collects excessive personal information from children\",\n                    \"HIGH\",\n                    \"COPPA violation: Excessive data collection from minors\"\n                )\n            else:\n                self.add_result(\n                    \"COPPA Data Minimization\",\n                    \"PASS\",\n                    \"System follows data minimization principles\",\n                    \"INFO\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"COPPA Data Minimization\",\n                \"WARNING\",\n                f\"Test failed with error: {e}\",\n                \"MEDIUM\"\n            )\n    \n    def test_gdpr_compliance(self):\n        \"\"\"Test GDPR compliance requirements\"\"\"\n        logger.info(\"Testing GDPR compliance...\")\n        \n        # Test 1: Data subject rights - Right to access\n        try:\n            headers = {'Authorization': f'Bearer {self.api_key}'}\n            response = self.session.get(\n                f\"{self.target_url}/v1/user/data-export\", \n                headers=headers\n            )\n            \n            if response.status_code == 404:\n                self.add_result(\n                    \"GDPR Right to Access\",\n                    \"FAIL\",\n                    \"No data export endpoint available for users\",\n                    \"HIGH\",\n                    \"GDPR violation: Missing right to data portability\"\n                )\n            elif response.status_code == 200:\n                self.add_result(\n                    \"GDPR Right to Access\",\n                    \"PASS\",\n                    \"Data export endpoint available\",\n                    \"INFO\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"GDPR Right to Access\",\n                \"WARNING\",\n                f\"Test failed with error: {e}\",\n                \"MEDIUM\"\n            )\n        \n        # Test 2: Right to deletion\n        try:\n            headers = {'Authorization': f'Bearer {self.api_key}'}\n            response = self.session.delete(\n                f\"{self.target_url}/v1/user/delete-account\", \n                headers=headers\n            )\n            \n            if response.status_code == 404:\n                self.add_result(\n                    \"GDPR Right to Deletion\",\n                    \"FAIL\",\n                    \"No account deletion endpoint available\",\n                    \"HIGH\",\n                    \"GDPR violation: Missing right to erasure\"\n                )\n            elif response.status_code in [200, 202]:\n                self.add_result(\n                    \"GDPR Right to Deletion\",\n                    \"PASS\",\n                    \"Account deletion endpoint available\",\n                    \"INFO\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"GDPR Right to Deletion\",\n                \"WARNING\",\n                f\"Test failed with error: {e}\",\n                \"MEDIUM\"\n            )\n        \n        # Test 3: Consent management\n        try:\n            headers = {'Authorization': f'Bearer {self.api_key}'}\n            response = self.session.get(\n                f\"{self.target_url}/v1/user/consent\", \n                headers=headers\n            )\n            \n            if response.status_code == 404:\n                self.add_result(\n                    \"GDPR Consent Management\",\n                    \"FAIL\",\n                    \"No consent management endpoint available\",\n                    \"HIGH\",\n                    \"GDPR violation: Missing consent management\"\n                )\n            elif response.status_code == 200:\n                self.add_result(\n                    \"GDPR Consent Management\",\n                    \"PASS\",\n                    \"Consent management endpoint available\",\n                    \"INFO\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"GDPR Consent Management\",\n                \"WARNING\",\n                f\"Test failed with error: {e}\",\n                \"MEDIUM\"\n            )\n    \n    def test_input_validation(self):\n        \"\"\"Test input validation and injection vulnerabilities\"\"\"\n        logger.info(\"Testing input validation...\")\n        \n        # Test 1: SQL Injection\n        sql_payloads = [\n            \"'; DROP TABLE users; --\",\n            \"' OR '1'='1\",\n            \"'; SELECT * FROM users; --\",\n            \"' UNION SELECT * FROM users --\"\n        ]\n        \n        for payload in sql_payloads:\n            try:\n                headers = {'Authorization': f'Bearer {self.api_key}'}\n                data = {\n                    'platform': 'api',\n                    'user': {\n                        'email': payload,\n                        'age': 10\n                    }\n                }\n                response = self.session.post(\n                    f\"{self.target_url}/v1/conversation/start\", \n                    json=data, \n                    headers=headers\n                )\n                \n                # Check for SQL error messages\n                if any(error in response.text.lower() for error in \n                       ['sql', 'mysql', 'postgres', 'database', 'syntax error']):\n                    self.add_result(\n                        \"SQL Injection Vulnerability\",\n                        \"FAIL\",\n                        f\"SQL injection possible with payload: {payload}\",\n                        \"HIGH\",\n                        \"Data breach risk\"\n                    )\n                    break\n            except Exception as e:\n                continue\n        else:\n            self.add_result(\n                \"SQL Injection Vulnerability\",\n                \"PASS\",\n                \"No SQL injection vulnerabilities detected\",\n                \"INFO\"\n            )\n        \n        # Test 2: XSS (Cross-Site Scripting)\n        xss_payloads = [\n            \"<script>alert('XSS')</script>\",\n            \"javascript:alert('XSS')\",\n            \"<img src=x onerror=alert('XSS')>\",\n            \"';alert('XSS');//\"\n        ]\n        \n        for payload in xss_payloads:\n            try:\n                headers = {'Authorization': f'Bearer {self.api_key}'}\n                data = {\n                    'sessionId': 'test-session',\n                    'message': {\n                        'type': 'text',\n                        'content': payload\n                    }\n                }\n                response = self.session.post(\n                    f\"{self.target_url}/v1/conversation/message\", \n                    json=data, \n                    headers=headers\n                )\n                \n                # Check if payload is reflected without encoding\n                if payload in response.text and '<script>' in response.text:\n                    self.add_result(\n                        \"XSS Vulnerability\",\n                        \"FAIL\",\n                        f\"XSS vulnerability detected with payload: {payload}\",\n                        \"HIGH\",\n                        \"Client-side code execution risk\"\n                    )\n                    break\n            except Exception as e:\n                continue\n        else:\n            self.add_result(\n                \"XSS Vulnerability\",\n                \"PASS\",\n                \"No XSS vulnerabilities detected\",\n                \"INFO\"\n            )\n    \n    def test_rate_limiting(self):\n        \"\"\"Test rate limiting implementation\"\"\"\n        logger.info(\"Testing rate limiting...\")\n        \n        try:\n            headers = {'Authorization': f'Bearer {self.api_key}'}\n            \n            # Send rapid requests to test rate limiting\n            responses = []\n            for i in range(100):  # Send 100 requests rapidly\n                response = self.session.get(\n                    f\"{self.target_url}/health\", \n                    headers=headers,\n                    timeout=5\n                )\n                responses.append(response.status_code)\n                \n                if response.status_code == 429:  # Rate limited\n                    break\n            \n            if 429 in responses:\n                self.add_result(\n                    \"Rate Limiting\",\n                    \"PASS\",\n                    \"Rate limiting is properly implemented\",\n                    \"INFO\"\n                )\n            else:\n                self.add_result(\n                    \"Rate Limiting\",\n                    \"FAIL\",\n                    \"No rate limiting detected - DoS vulnerability\",\n                    \"MEDIUM\",\n                    \"Service availability risk\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"Rate Limiting\",\n                \"WARNING\",\n                f\"Test failed with error: {e}\",\n                \"MEDIUM\"\n            )\n    \n    def test_data_encryption(self):\n        \"\"\"Test data encryption in transit and at rest\"\"\"\n        logger.info(\"Testing data encryption...\")\n        \n        # Test 1: HTTPS enforcement\n        try:\n            http_url = self.target_url.replace('https://', 'http://')\n            response = requests.get(f\"{http_url}/health\", timeout=10)\n            \n            if response.status_code == 200:\n                self.add_result(\n                    \"HTTPS Enforcement\",\n                    \"FAIL\",\n                    \"API accepts HTTP connections - data transmitted in plaintext\",\n                    \"HIGH\",\n                    \"GDPR/COPPA: Unencrypted data transmission\"\n                )\n            else:\n                self.add_result(\n                    \"HTTPS Enforcement\",\n                    \"PASS\",\n                    \"API properly enforces HTTPS\",\n                    \"INFO\"\n                )\n        except Exception as e:\n            self.add_result(\n                \"HTTPS Enforcement\",\n                \"PASS\",\n                \"HTTP connections rejected or redirected\",\n                \"INFO\"\n            )\n        \n        # Test 2: TLS version and cipher strength\n        try:\n            import ssl\n            import socket\n            \n            hostname = self.target_url.replace('https://', '').replace('http://', '').split('/')[0]\n            context = ssl.create_default_context()\n            \n            with socket.create_connection((hostname, 443)) as sock:\n                with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                    tls_version = ssock.version()\n                    cipher = ssock.cipher()\n                    \n                    if tls_version in ['TLSv1.2', 'TLSv1.3']:\n                        self.add_result(\n                            \"TLS Version\",\n                            \"PASS\",\n                            f\"Strong TLS version in use: {tls_version}\",\n                            \"INFO\"\n                        )\n                    else:\n                        self.add_result(\n                            \"TLS Version\",\n                            \"FAIL\",\n                            f\"Weak TLS version detected: {tls_version}\",\n                            \"HIGH\",\n                            \"Encryption vulnerability\"\n                        )\n        except Exception as e:\n            self.add_result(\n                \"TLS Version\",\n                \"WARNING\",\n                f\"TLS test failed: {e}\",\n                \"MEDIUM\"\n            )\n    \n    def run_zap_active_scan(self):\n        \"\"\"Run OWASP ZAP active security scan\"\"\"\n        logger.info(\"Running ZAP active scan...\")\n        \n        try:\n            # Spider the application first\n            logger.info(\"Starting spider scan...\")\n            scan_id = self.zap.spider.scan(self.target_url)\n            \n            # Wait for spider to complete\n            while int(self.zap.spider.status(scan_id)) < 100:\n                time.sleep(2)\n            \n            logger.info(\"Spider scan completed\")\n            \n            # Start active scan\n            logger.info(\"Starting active scan...\")\n            scan_id = self.zap.ascan.scan(self.target_url)\n            \n            # Wait for active scan to complete\n            while int(self.zap.ascan.status(scan_id)) < 100:\n                time.sleep(5)\n                progress = self.zap.ascan.status(scan_id)\n                logger.info(f\"Active scan progress: {progress}%\")\n            \n            logger.info(\"Active scan completed\")\n            \n            # Get scan results\n            alerts = self.zap.core.alerts()\n            \n            high_risk_count = 0\n            medium_risk_count = 0\n            \n            for alert in alerts:\n                risk = alert.get('risk', 'Unknown')\n                if risk == 'High':\n                    high_risk_count += 1\n                elif risk == 'Medium':\n                    medium_risk_count += 1\n                \n                self.add_result(\n                    f\"ZAP Alert: {alert.get('name', 'Unknown')}\",\n                    \"FAIL\" if risk in ['High', 'Medium'] else \"WARNING\",\n                    alert.get('description', 'No description'),\n                    risk.upper(),\n                    \"Security vulnerability detected\" if risk in ['High', 'Medium'] else None\n                )\n            \n            if high_risk_count == 0 and medium_risk_count == 0:\n                self.add_result(\n                    \"ZAP Active Scan\",\n                    \"PASS\",\n                    \"No high or medium risk vulnerabilities detected\",\n                    \"INFO\"\n                )\n            \n        except Exception as e:\n            self.add_result(\n                \"ZAP Active Scan\",\n                \"WARNING\",\n                f\"Active scan failed: {e}\",\n                \"MEDIUM\"\n            )\n    \n    def generate_report(self) -> Dict:\n        \"\"\"Generate comprehensive security test report\"\"\"\n        logger.info(\"Generating security test report...\")\n        \n        # Count results by status and risk\n        status_counts = {'PASS': 0, 'FAIL': 0, 'WARNING': 0}\n        risk_counts = {'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'INFO': 0}\n        compliance_issues = []\n        \n        for result in self.results:\n            status_counts[result.status] += 1\n            risk_counts[result.risk_level] += 1\n            \n            if result.compliance_impact:\n                compliance_issues.append({\n                    'test': result.test_name,\n                    'impact': result.compliance_impact,\n                    'risk': result.risk_level\n                })\n        \n        # Calculate security score\n        total_tests = len(self.results)\n        security_score = (status_counts['PASS'] / total_tests * 100) if total_tests > 0 else 0\n        \n        report = {\n            'timestamp': datetime.now().isoformat(),\n            'target_url': self.target_url,\n            'summary': {\n                'total_tests': total_tests,\n                'security_score': round(security_score, 2),\n                'status_counts': status_counts,\n                'risk_counts': risk_counts\n            },\n            'compliance': {\n                'coppa_compliant': risk_counts['HIGH'] == 0 and len([r for r in self.results if 'COPPA' in r.test_name and r.status == 'FAIL']) == 0,\n                'gdpr_compliant': risk_counts['HIGH'] == 0 and len([r for r in self.results if 'GDPR' in r.test_name and r.status == 'FAIL']) == 0,\n                'issues': compliance_issues\n            },\n            'detailed_results': [\n                {\n                    'test_name': r.test_name,\n                    'status': r.status,\n                    'details': r.details,\n                    'risk_level': r.risk_level,\n                    'compliance_impact': r.compliance_impact\n                } for r in self.results\n            ]\n        }\n        \n        return report\n    \n    def run_all_tests(self) -> Dict:\n        \"\"\"Run all security tests\"\"\"\n        logger.info(\"Starting comprehensive security testing...\")\n        \n        # Setup ZAP\n        if not self.setup_zap():\n            logger.error(\"Failed to setup ZAP - some tests will be skipped\")\n        \n        # Run all test categories\n        self.test_authentication_security()\n        self.test_coppa_compliance()\n        self.test_gdpr_compliance()\n        self.test_input_validation()\n        self.test_rate_limiting()\n        self.test_data_encryption()\n        \n        # Run ZAP active scan if available\n        try:\n            self.run_zap_active_scan()\n        except Exception as e:\n            logger.warning(f\"ZAP active scan failed: {e}\")\n        \n        # Generate and return report\n        report = self.generate_report()\n        \n        logger.info(f\"Security testing completed. Score: {report['summary']['security_score']}%\")\n        logger.info(f\"High risk issues: {report['summary']['risk_counts']['HIGH']}\")\n        logger.info(f\"Medium risk issues: {report['summary']['risk_counts']['MEDIUM']}\")\n        \n        return report\n\ndef main():\n    \"\"\"Main function to run security tests\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='Run security tests for Storytailor API')\n    parser.add_argument('--url', required=True, help='Target API URL')\n    parser.add_argument('--api-key', required=True, help='API key for authentication')\n    parser.add_argument('--zap-port', type=int, default=8080, help='ZAP proxy port')\n    parser.add_argument('--output', default='security_report.json', help='Output report file')\n    \n    args = parser.parse_args()\n    \n    # Run security tests\n    tester = StorytellerSecurityTester(args.url, args.api_key, args.zap_port)\n    report = tester.run_all_tests()\n    \n    # Save report\n    with open(args.output, 'w') as f:\n        json.dump(report, f, indent=2)\n    \n    logger.info(f\"Security report saved to {args.output}\")\n    \n    # Exit with error code if high risk issues found\n    if report['summary']['risk_counts']['HIGH'] > 0:\n        logger.error(\"High risk security issues detected!\")\n        sys.exit(1)\n    elif report['summary']['risk_counts']['MEDIUM'] > 0:\n        logger.warning(\"Medium risk security issues detected\")\n        sys.exit(2)\n    else:\n        logger.info(\"No high or medium risk security issues detected\")\n        sys.exit(0)\n\nif __name__ == '__main__':\n    main()"